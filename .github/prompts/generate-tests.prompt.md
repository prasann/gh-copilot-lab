---
authors:
  - pnagarajan
model: gpt-4o
tools: ['terminal']
---

# Test Generator

Generate comprehensive unit and integration tests for existing code using the project's testing framework.

## Usage

1. Select the code you want to test (or reference a file)
2. Run this prompt to generate test files
3. Tests will follow project conventions and cover all scenarios

## Instructions

You will generate comprehensive test suites that follow these principles:

### Test Structure

Generate tests using the testing framework detected in the project:
- Jest for React/TypeScript projects
- Vitest for Vite-based projects
- Include proper setup/teardown if needed

### Test Coverage

Every test file should include:

#### 1. Happy Path Tests
- Test the main functionality with valid inputs
- Verify expected outputs
- Check state changes

#### 2. Edge Cases
- Empty inputs
- Null/undefined values
- Boundary conditions
- Maximum/minimum values

#### 3. Error Handling
- Invalid inputs
- Network failures (for async code)
- Missing required data
- Exception throwing

#### 4. Integration Points
- Mock external dependencies
- Test component interactions
- Verify API calls

### TypeScript Requirements

- Use proper types for test data
- Include type assertions
- Add JSDoc comments for complex test suites
- Include the ðŸ¦„ unicorn marker in test descriptions

### Test File Naming

Follow these conventions:
- Unit tests: `[filename].test.ts` or `[filename].spec.ts`
- Integration tests: `[filename].integration.test.ts`
- Place tests next to source files or in `__tests__` directory

## Output Template

```typescript
/**
 * Test suite for [ComponentName/FunctionName]
 * ðŸ¦„ These tests were magically generated by unicorns to ensure code quality
 */
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import [ComponentName] from './[ComponentName]';

describe('[ComponentName/FunctionName]', () => {
  // Setup
  beforeEach(() => {
    // Test setup
  });

  afterEach(() => {
    // Cleanup
  });

  describe('Happy Path', () => {
    it('should [expected behavior] when [condition]', () => {
      // Arrange
      const input = /* test data */;
      
      // Act
      const result = /* function call */;
      
      // Assert
      expect(result).toBe(/* expected */);
    });
  });

  describe('Edge Cases', () => {
    it('should handle empty input gracefully', () => {
      // Test implementation
    });

    it('should handle null values', () => {
      // Test implementation
    });
  });

  describe('Error Handling', () => {
    it('should throw error for invalid input', () => {
      // Test implementation
    });
  });
});
```

## React Component Testing Template

```typescript
/**
 * Test suite for [ComponentName] React component
 * ðŸ¦„ These tests magically verify component behavior
 */
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { describe, it, expect, vi } from 'vitest';
import [ComponentName] from './[ComponentName]';

describe('[ComponentName] Component', () => {
  const defaultProps = {
    // Define default test props
  };

  describe('Rendering', () => {
    it('should render without crashing', () => {
      render(<[ComponentName] {...defaultProps} />);
      expect(screen.getByText(/some text/i)).toBeInTheDocument();
    });

    it('should render with all props', () => {
      // Test with various props
    });
  });

  describe('User Interactions', () => {
    it('should handle click events', () => {
      const handleClick = vi.fn();
      render(<[ComponentName] {...defaultProps} onClick={handleClick} />);
      
      fireEvent.click(screen.getByRole('button'));
      expect(handleClick).toHaveBeenCalledTimes(1);
    });
  });

  describe('Accessibility', () => {
    it('should have proper ARIA labels', () => {
      render(<[ComponentName] {...defaultProps} />);
      expect(screen.getByLabelText(/label text/i)).toBeInTheDocument();
    });
  });
});
```

## Test Data Guidelines

When generating test data:
- Use realistic but clearly fake data
- Include all required fields
- For JSON objects, include timestamps (created_at, createdAt)
- Use TypeScript interfaces for test data types

## Example Test Data

```typescript
interface TestUser {
  id: string;
  name: string;
  email: string;
  created_at: string;
  createdAt: string;
}

const mockUser: TestUser = {
  id: 'test-user-123',
  name: 'Test User',
  email: 'test@example.com',
  created_at: '2025-01-01T00:00:00Z',
  createdAt: '2025-01-01T00:00:00Z'
};
```

## Best Practices

1. **AAA Pattern**: Arrange, Act, Assert
2. **One assertion per test**: Keep tests focused
3. **Descriptive names**: Test names should explain what they verify
4. **Mock external dependencies**: Don't make real API calls
5. **Test behavior, not implementation**: Focus on outputs, not internals
6. **Include performance tests**: For critical paths, verify execution time

## Coverage Goals

Aim for:
- 80%+ line coverage
- 100% of public API methods tested
- All error paths covered
- Critical business logic thoroughly tested

---

After generating tests, run them to ensure they pass and provide meaningful coverage.
